---
title: Linux
description: Linux
---

### Что такое LA? В каких единицах измеряется?

LA (load average) -- параметр, определяющий среднюю нагрузку на систему за
период времени (1 мин, 5 минут, 15 минут). Изменяется в количестве задач на
одно ядро процессора. На нагрузку системы также влияет количество задач
ввода-вывода и задержка сети. Также влияние на расчета LA оказывает: 1.
Технология Hyper-Threading, которая делит одно физическое ядро на 2
логических, 2. Технология Turbo Bust, которая позволяет разгонять тактовую
частоту процессора и работать на частоте выше заявленной, т.е. выше
номинальной частоты (время на обработку одной задачи уменьшается).

### Что будет если на сервере LA = 100?

Вероятно, что на сервере будет наблюдаться замедленная работа сервисов, но если параметр LA равен количеству ядер в системе или количеству потоков в системе, то данная нагрузка является нормальной.

### Почему при высоких показателях значения LA на сервере может не наблюдаться проблем (консоль ssh отзывается, сервисы работают в обычном режиме)?

На параметр нагрузки LA влияет также и ожидание ввода-вывода (параметр *wa* в утилите *top*) в дисков и задержка сети. Данные параметры могут не влиять на работу основных сервисов в системе, но учитываются при расчете общей нагрузки на систему.

### Представлен вывод команды *top*. Что означает каждая запись в выводе?

```
top - 21:29:24 up 14:18,  1 user,  load average: 0,78, 1,48,   1,10
Tasks: 277 total,   3 running, 274 sleeping,   0 stopped,      0 zombie
%Cpu(s): 12,4 us,  2,5 sy,  0,1 ni, 84,8 id,  0,1 wa,  0,0   hi,  0,1 si,  0,0 st
KiB Mem :  7106404 total,   306972 free,  3127144 used,    3672288 buff/cache
KiB Swap:  8191996 total,  8191996 free,        0 used.    3270520 avail Mem
```

- *top* - название утилиты.
- *21:29:24* - текущее время системы.
- *up 14:18* - сколько часов:минут система работает с момента последнего запуска.
- *1 user* - количество пользователей авторизованных в системе.
- *load average: 0,78, 1,48, 1,10* - параметр средней нагрузки на систему за период времени 1 минута, 5 минут, 15 минут.
- *277 total* - всего процессов в системе.
- *3 running* - количество процессов в работе.
- *274 sleeping* - количество процессов в состоянии sleeping: ожидает какого-либо события или сигнала.
- *0 stopped* - количество приостановленных процессов сигналом STOP или выполнением трассировки.
- *0 zombie* - количество зомби-процессов, которые завершили своё выполнение, но присутствующие в системе, чтобы дать родительскому процессу считать свой код завершения.

| Параметр                      | Описание                                                                                       |
| ----------------------------- | ---------------------------------------------------------------------------------------------- |
| us (user)                     | Использование процессора пользовательским процессами                                           |
| sy (system)                   | Использование процессора системным процессами                                                  |
| ni (nice)                     | Использование процессора процессами с измененным приоритетом с помощью команды nice            |
| id (idle)                     | Простой процессора. Можно сказать, что это свободные ресурсы                                   |
| wa (IO-wait)                  | Говорит о простое, связанным с вводом/выводом                                                  |
| hi (hardware interrupts)      | Показывает сколько процессорного времени было потрачено на обслуживание аппаратного прерывания |
| si (software interrupts)      | Показывает сколько процессорного времени было потрачено на обслуживание софтверного прерывания |
| st (stolen by the hypervisor) | Показывает сколько процессорного времени было «украдено» гипервизором                          |

KiB Mem - количество оперативной памяти в кибибайтах (кратно 1024): *7106404 total* -- всего доступно оперативной памяти в системе, *306972 free* -- свободно оперативной памяти для использования, *3127144 used* -- использовано оперативной памяти, *3672288 buff/cache* -- буферизовано/закешировано оперативной памяти.

*KiB Swap* - количество swap-памяти в кибибайтах (кратно 1024), которые выделено на диске: *8191996 total* - всего выделено swap-памяти, *8191996 free* - свободно swap-памяти *0 used* - использовано swap-памяти, *3270520 avail Mem* - доступно для использования swap-памяти.

### Как в утилите top в Linux посмотреть нагрузку на каждое ядро процессора?

В утилите top нажать `1`, чтобы отобразить все ядра в системе.

### Как в утилите top в Linux посмотреть какой командой был запущен процесс?

В утилите top нажать `c`, чтобы отобразить команды, которыми были запущены процессы.

### Где хранятся имена файлов/директорий?

В Unix имена файлов и директорий хранятся в **каталогах** — это специальные файлы, где каждая запись содержит имя и ссылку на **inode**. Сам inode хранит уже метаданные (размер, права, владельца, временные метки и указатели на блоки данных), но **не имя**. Таким образом, имя → в каталоге, а содержимое и свойства файла → в inode и блоках данных.

### Как удалить файл с именем `-rf`?

```bash
rm ./-rf
```

### Как посмотреть описание дискриптора?

Посмотреть полную информацию по дискриптору возможно командой

```bash
stat <path_to_file>
```

### Как посмотреть время последней модификации файла?

Можно через `stat` с нужным форматом:

```bash
stat --format=%y <file>
```

### Для чего нужна переменная окружения PATH?

Переменная окружения **`PATH`** нужна для того, чтобы система знала, **в каких каталогах искать исполняемые файлы команд**.

### Как посмотреть нагрузку на диски?

Нагрузку на диски можно смотреть несколькими способами:

- **`iostat`** (часть пакета `sysstat`) — показывает загрузку дисков, количество операций ввода-вывода, скорость чтения/записи:

```bash
iostat -x 1
```

- **`iotop`** — утилита наподобие `top`, но для дисков; отображает процессы, которые создают нагрузку:

```bash
iotop
```

- **`dstat`** — универсальный инструмент для мониторинга ресурсов, в том числе ввода-вывода:

```bash
dstat -d
```

- Для быстрой оценки использования места на диске (но это не нагрузка, а именно занятое пространство):

```bash
df -h
```

### Что такое файл в понятиях Unix-like операцинных системах?

Файлы - это объекты, в которые мы записываем информацию и наши данные, исполняемые файлы, но кроме этих привычных нам понятий здесь есть файлы специального назначения - файлы устройств, файлы туннелей, сокетов и многое другое.

Типы файлов в Linux:

- Обычные файлы, для хранения информации;
- Специальные файлы - для устройств и туннелей;
- Директории.

### Что такое RAID? Какие массивы бывают?

**RAID (Redundant Array of Independent/Inexpensive Disks)** — это технология, которая объединяет несколько физических дисков в единый логический массив для повышения **надёжности**, **производительности** или и того, и другого вместе.

Основные уровни RAID:

- **RAID 0 (striping)** – данные распределяются по дискам без избыточности. Максимальная скорость, но надёжности нет: выход из строя одного диска → потеря данных.
- **RAID 1 (mirroring)** – зеркалирование: данные дублируются на два и более диска. Высокая надёжность, но теряется половина ёмкости.
- **RAID 5** – чередование данных с распределённой контрольной суммой (parity). Требует минимум 3 дисков, даёт баланс скорости и отказоустойчивости.
- **RAID 6** – как RAID 5, но с двумя копиями контрольных сумм. Выдерживает выход из строя двух дисков, но медленнее записи.
- **RAID 10 (1+0)** – комбинация RAID 1 и RAID 0: зеркалирование + распределение по дискам. Требует минимум 4 дисков, сочетает скорость и надёжность.

👉 В реальной практике чаще всего используют **RAID 1, 5, 6 и 10**.

### При каком количестве одновременно вышедших из строя дисков обеспечивает работоспособность RAID 6?

2 диска.

### В чем разница между объявлением переменной `export VAR="VALUE"` и `VAR="VALUE"` в bash?

При объявлении переменной через export - переменная будет доступна в любых других процессах, при обычном объявлении переменной - переменная будет доступна только в запущенном процессе.

### Как остановить выполнение скрипта в bash при возникновении ошибки в команде?

Команда `set -e` завершит скрипт с ошибкой, в случае, если в нижеследующем bash коде будет обнаружена ошибка. По-умолчанию bash скрипт продолжает работу, если в ходе выполнения возникла ошибка.

### Что в bash скрипте означает команда `set -euo pipefail`?

Команда `set` устанавливает аттрибуты оболочки с опеределенных опций.
Опция `-e` - означает, что скрипт будет остановлен, когда произойдет ошибка в ходе его выполнения.
Опция `-u` - означает, что скрипт будет остановлен, если в ходе скрипта, будет обнаружена переменная, которая не определена.
Опция `-o pipefail` - означает, что скрипт будет остановлен, если в ходе пайплайна команд будет выявлена ошибка.

### Как активировать debug режим в bash?

Команда `set -x` в начале скрипта активирует вывод в консоль debug информации.

### Что значит `$@` в bash?

`$@` - все параметры переданные скрипту.

### Какой код сигнала будет выполнен при исполнении команды `kill <PID>`?

Сигнал SIGTERM (код 15) - это сигнал по-умолчанию отправляемый при вызове команды kill. Это указывает процессу на завершение работы и обычно считается сигналом для использования при чистом завершении работы.

### Как выполнить фильтрацию вывода команды, чтобы на экран были выведены только ошибки (STDERR), игнорируя STDOUT?

Для этого нужно перенаправить стандартный вывод (STDOUT) в «никуда», а стандартный поток ошибок (STDERR) оставить:

```bash
command > /dev/null
```

В этом случае на экран попадут только ошибки (STDERR).

### Какую команду необходимо выполнить, чтобы посмотреть какие пользователи вошли в систему в систему?

Команда `w` покажет список пользователей, которые вошли на сервер.

### Какой файл необходимо отредактировать, чтобы отключить ssh аутентификацию по паролю?

Необходимо редактировать файл `/etc/ssh/sshd_config`, отвечающий за конфигурацию сервиса ssh.

### В каком файле находится информация о смонтированных каталогах в файловую систсему?

Файл `/etc/fstab` содержит информацию о смонтированных каталогах в файловую систему.

### Что выведет команда `cat a` и почему?

```bash
mkdir /tmp/abc
cd /tmp/abc
ls >a 2>b
cat a
```

Обработка команды идёт справа налево. Сначала создается файл _b_, потом создается файл _a_, команда `ls` отображает список файлов в текущей директории (файлы _a_ и _b_ уже созданы) в одну колонну и перенаправляет стандартный поток вывода (`>`) в файл _a_, а стандартный поток ошибок `2` в файл _b_.

### В bash-скрипте указан аттрибут оболочки `set -x`. В одной из команд происходит ошибка и скрипт завершает свою работу. Как сделать, чтобы при возникновении ошибки в определенной команде скрипт продолжил свою работу?

1 вариант: указать `|| true` после выполнения команды с ошибкой.

```sh
<command with error> || true
```

2 вариант: до выполнения данной команды указать `set +e` для игнорирования ошибок, начиная со следующей строки и после выполнения команды указать `set -e` для завершения работы скрипта в случае ошибки, начиная со следующей строки.

```sh
set -e
<command 1>
<command 2>
set +e
<command 3 wih error>
set -e
```

### Что такое системный вызов, какие они бывают?

Системный вызов - обращение программы к ядру операционной системы для выполнения какой-либо операции.

В Unix, Unix-like и других POSIX-совместимых операционных системах популярными системными вызовами являются:

- open,
- read,
- write,
- close,
- wait,
- exec,
- fork,
- exit,
- kill.

### Что такое сигнал в Unix, зачем они нужны и разница между 9 и 15 сигналами?

Сигнал - в Unix-like операционных системах - асинхронное (в случайное время) уведомление процесса для обработки какого-либо события. Один из основных способов взаимодействия между процессами.

Посылка сигналов от одного процесса к другому обычно осуществляется при помощи системного вызова _kill_. Его первый параметр – PID процесса, которому посылается сигнал; второй параметр – номер сигнала.

```
kill(1111, SIGTERM);
```

Стандарт POSIX определяет 28 сигналов. Некоторые из них:

| Сигнал  | Код | Описание                                                 |
| ------- | --- | -------------------------------------------------------- |
| SIGTERM | 15  | Сигнал завершения (сигнал по умолчанию для утилиты kill) |
| SIGKILL | 9   | Безусловное завершение                                   |
| SIGSTOP | 23  | Остановка выполнения процесса                            |
| SIGHUP  | 1   | Закрытие терминала (перечитать конфигурацию)             |
| SIGINT  | 2   | Сигнал прерывания (Ctrl-C) с терминала                   |

### Что такое inode? Какая информация там хранится?

Inode (индексный дескриптор) - структура данных, в которой хранятся метаданные файла и перечислены блоки с данными файла. Хранит всю информацию, кроме имени файла и данных. Каждый файл в данном каталоге является записью с именем файла и номером индекса. Вся остальная информация о файле извлекается из таблицы индексов путем ссылки на номер индекса. Номера inodes уникальны на уровне раздела. Каждый раздел как собственная таблица индексов. Если у вас закончились inode, вы не можете создавать новые файлы, даже если у вас есть свободное место на данном разделе.

Inodes хранит метаданные о файле, к которому он относится. Эти метаданные содержат всю информацию об указанном файле.

- Размер.
- Разрешение.
- Владелец/группа.
- Расположение жесткого диска.
- Дата/время.
- Любая другая необходимая информация.

### Что такое hard link? В чем разница между hard link и soft link? Примеры их практического применения.

**Hard link**:
Ссылка на файл в файловой системе с использованием такого же inode идентификатора, как у файла, на который ссылаемся.
Создадим файл _realFile_.

```
touch realFile
```

Создадим hard link командой `ln <целевой_файл> <файл_ссылка>`:

```
ln realFile hardLink
```

Проверим, что inode у файла _realFile_ и hard ссылке _hardLink_ имеют одинаковый идентификатор.

```
$ ls -li
итого 0
2359720 -rw-r--r-- 2 rmntrvn rmntrvn 0 апр 25 23:24 hardLink
2359720 -rw-r--r-- 2 rmntrvn rmntrvn 0 апр 25 23:24 realFile
```

Как видно realFile и hardLink имеют одинаковый идентификатор inode.

**Soft link**:
Создадим soft ссылку на файл _realFile_.

```
ln -s realFile softLink
```

Проверим, что числовой идентификатор _softLink_ отличается от числового идентификатора _realFile_.

```
$ ls -li
итого 0
2359720 -rw-r--r-- 2 rmntrvn rmntrvn 0 апр 25 23:24 hardLink
2359720 -rw-r--r-- 2 rmntrvn rmntrvn 0 апр 25 23:24 realFile
2366763 lrwxrwxrwx 1 rmntrvn rmntrvn 8 апр 25 23:29 softLink -> realFile
```

Некоторые нюансы:

- Soft ссылки используют различные номера inode, чем основные файлы.
- Soft ссылки становятся полезными, если исходный файл был удален.
- Soft ссылки могут быть созданы из каталогов.
- Soft ссылка может быть создана на пересечении файловых систем.

- Hard ссылка может размещаться только на том же логическом разделе, что и оригинальный файл. Это связано с независимой идентификацией файлов на разных разделах.
- Создание жестких ссылок не поддерживается для папок — только для файлов.
- Файловая система должна поддерживать работу с hard ссылками.

### Какие состояния процессов существуют? Что значит состояние процесса D?

|                   **Статус**                   |              **Описание**               |
| :--------------------------------------------: | :-------------------------------------: |
|            R (running or runnable)             |   Выполняется или готов к выполнению    |
|           D (uninterruptible sleep)            |         Ожидает записи на диск          |
|            S (interruptible sleep)             |           Неактивен (< 20 s)            |
|       T (stopped by job control signal)        | Остановлен или трассируется отладчиком  |
|                   Z (zombie)                   |                  зомби                  |
| W (paging (not valid since the 2.6.xx kernel)) |        Процесс выгружен на диск         |
|                      `<`                       | Процесс имеет повышенный приоритет nice |
|                       N                        | Процесс имеет пониженный приоритет nice |
|                   L (locked)                   |  Некоторые страницы блокированы в ядре  |
|                       s                        |     Процесс является лидеров сеанса     |

### Что такое процесс-зомби и процесс-сирота? Можно ли самостоятельно сделать зомби?

_Процесс-зомби_ - дочерний процесс в Unix-системе, завершивший своё выполнение, но ещё присутствующий в списке процессов операционной системы, чтобы дать родительскому процессу считать код завершения.

Удаление зомби возлагается на родительский процесс или системный вызов `wait()` также может это выполнить, поэтому перед ее вызовом не нужно проверять, продолжает ли выполняться требуемый дочерний процесс. Если родительский процесс не удалит своих потомков, то они останутся в состоянии зомби.

Убить зомби-процесс невозможно. Чтобы убить зомби-процесс нужно найти родительский процесс и завершить его или перезапустить. Найти зомби-процессы и их родителей можно следующей командой:

```
ps ajx | grep -w Z
```

PID'ы процессов родителей в 3 колонке. Убить процесс следующей командой:

```
kill -9 <PID процесса родителя>
```

_Процесс-сирота_ — в семействе операционных систем UNIX вспомогательный процесс, чей основной процесс (или связь с ним) был завершен нештатно (не подав сигнала на завершение работы).

Отличие в том, что процесс-сирота (orphan process) всё еще активен. Его родительский процесс был по какой-либо причине прерван, и сирота теперь переходит под руководство init, чей ID процесса равен 1. PPID orphan процесса получит значение 1. Пользователь также может создать подобный процесс, отсоединив его от терминала. Сиротские процессы используют много ресурсов, их легко найти с помощью top или htop.

В отличии от процесса-сироты, зомби-процесс неактивен, но контролируется родительским процессом, пока тот не решит, что статус выхода дочерних процессов больше не нужен. Он не использует ресурсы и не может быть запланирован для выполнения. Иногда родительский процесс удерживает дочерний процесс в состоянии зомби, чтобы гарантировать, что будущие дочерние процессы не получат тот же PID. Если вы уничтожите родителя зомби-процесса, зомби-процесс тоже умрет. Для этого найдите родительский PID (PPID) зомби и отправьте ему сигнал SIGCHLD (17): kill -17 ppid.

### Что такое файловый дескриптор? Какая информация там хранится?

_Файловый дескриптор_ - неотрицательное целое число, которое используется в интерфейсе между пространством пользователя и пространством ядра (kernel) для идентификации ресурсов файла / сокета. Когда создаётся новый поток ввода-вывода, ядро возвращает процессу, создавшему поток ввода-вывода, его файловый дескриптор.

### Что такое buffer/cache память? Для чего нужна?

buff/cache память - рассчитанная память, которая зарезервирована, но может быть освобождена при необходимости и используется для быстрого доступа программами к данным, которые находятся в оперативной памяти (быстрой памяти).

buffers — буферы в памяти — страницы памяти, зарезервированные системой для выделения их процессам, когда они затребуют этого, так же известна как heap-memory;
cached — файлы, которые недавно были использованы системой/процессами и хранящиеся в памяти на случай если вскоре они снова потребуются.

### Представлен вывод команды `free`. Почему доступной (available) памяти сейчас 2919, если свободной (free) памяти 843?

```
$ free -m
              total        used        free      shared  buff/cache   available
Mem:           6930        3598         843         183        2489        2919
Swap:         15999           4       15995
```

- Total. Эта цифра представляет всю существующую память.
- Used вычисление общего значения оперативной памяти системы за вычетом выделенной свободной, разделяемой, буферной и кэш-памяти.

```
used = total - free - buff/cache
```

- Free – свободная память в системе.
- Shared – память, используемая (преимущественно) в tmpfs
- Buffer, и Cache идентифицируют память, используемую для нужд ядра / операционной системы. Буфер и кеш складываются вместе, а сумма указывается в разделе «buff/cache».
- Available – примерное количество оперативной памяти, доступное для запуска новых приложений без использования ими раздела подкачки. В отличие от поля free, это поле принимает в расчёт страницу cache и также то, что не вся рекуперируемая (пригодная для повторного использования) память будет возвращена для рекуперации из-за того, что элементы используются в данный момент.

### Порядок загрузки дистрибутива Linux.

1. Включение компьютера кнопкой.
2. Загрузить BIOS / UEFI из NVRAM.
3. Собрать сведения об аппаратуре.
4. Выбрать устройства для запуска (диск, сеть).
5. Идентифицировать системный раздел EFI.
6. Загрузить BIOS / UEFI из NVRAM.
7. Определить какое ядро загрузить.
8. Загрузить ядро.
9. Создать структуры данных ядра.
10. Запустить init / systemd как PID 1.
11. Выполнить сценарии запуска.
12. Запустить систему.
