---
title: Docker
description: Docker
---
### Что такое docker и какие инструменты linux лежат в основе? Для чего он используется?


Docker базируется на технологиях **namespaces**, **cgroups**, **capabilities**, **overlay**
**namespaces** - обеспечивает изоляцию. Используется для изоляции. Например, можно айдишники процессов разместить в разных контейнерах.
**cgroup** - штука, которая позволяет управлять группой процессов, и управлять их ресурсами.
**capabilites** - штука, которая позволяет дать некоторые рут привелегии процессам или исполняемым файлам. Например, изменить UID процесса на 0, или дать возможность монтировать файловые системы.
**overlay (overlayFS, overlay2-драйвер)** - файловая система, которая умеет работать "слоями". Не сохранять каждый раз новые файлы, а наслаивать один слой на другой, тем самым экономя место на диске и время создания контейнера.

А вот докер - это уже штука, которая всеми этими технологиями рулит. Да ещё и удобным для нас образом.

Компоненты докера:
1. Docker Daemon — то самое Container Engine; запускает контейнеры.
2. Docker CII — утилита по управлению Docker.
3. Dockerfile — инструкция по тому, как собирать образ.
4. Image — образ, из которого раскатывается контейнер.
5. Container.
6. Docker registry — хранилище образов.

![Docker](./img/docker/docker.png)

На Docker_host работает Docker daemon, запускает контейнеры. Есть Client, который передаёт команды: собери образ, скачай образ, запусти контейнер. Docker daemon ходит в registry и выполняет их. Docker-клиент может обращаться и локально (к юникс-сокету), и по TCP с удалённого хоста.

Docker daemon (демон) — это серверная часть, она работает на хост-машине: скачивает образы и запускает из них контейнеры, создаёт сеть между контейнерами, собирает логи. Когда мы говорим «создай образ», этим тоже занимается демон.

Docker CLI — клиентская часть Docker, консольная утилита для работы с демоном. Повторю, она может работать не только локально, но и по сети.

### Что такое контейнеры, образы? В чём заключаются концепции их использования?

**Образ** - шаблон приложения, который содержит слои файловой системы в режиме "только-чтение".
**Контейнер** - запущенный образ приложения, который кроме нижних слоев в режиме "только чтение" содержит верхний слой в режиме "чтение-запись".
Контейнер - это уже развернутое и запущенное приложение. Однажды запущенный контейнер сохранён в библиотеке, его можно останавливать, менять настройки, перезапускать, но до удаления контейнера это некоторая постоянная сущность со своим id. Продолжая аналогию с установкой ПО, контейнер можно сравнить с уже установленной и работающей программой на ПК.
Образ - Это неизменяемый образ, из которого разворачивается контейнер. Его можно рассматривать как набор файлов, необходимых для запуска и работы приложения на другом хосте. Можно привести аналогию из мира установки ПО: образ — это компакт-диск, с которого устанавливается программа.

### В каком виде хранятся образы? Для чего используются слои? Что представляет собой overlayfs?

**Образы(images)** - это логическая группировка слоев плюс метаданные о том, что делать при создании контейнера и как собирать слои. Часть этих метаданных заключается в том, что каждый слой знает ID своего родителя.
Итак, что входит в слой? Файлы (и каталоги), которые вы добавили в родительский файл. Существуют также специальные файлы ("whiteout"), которые указывают на то, что что-то было удалено из родительского файла.
Docker-image — шаблон только для чтения (read-only) с набором некоторых инструкций, предназначенных для создания контейнера. Он состоит из слоев, которые Docker комбинирует в один образ при помощи вспомогательной файловой системы UnionFS. Так решается проблема нерационального использования дисковой памяти. Параметры образа определяются в Docker-file.

### Что такое docker commit

Это утилита, с помощью которой можно сощздать новый образ на основе контейнера либо перезаписать текущий образ

Может быть полезно когда ты что ты изменил какой то файл в docker контейнере, и тебе нужно сохранить этот новый рабочий обновленный образ.

### Какие инструкции есть у Dockerfile?

| Инструкция | Описание                                                                                                                                                                                                   |
| ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| FROM       | Задаёт базовый (родительский) образ.                                                                                                                                                                       |
| LABEL      | Описывает метаданные. Например — сведения о том, кто создал и поддерживает образ.                                                                                                                          |
| ENV        | Устанавливает постоянные переменные среды.                                                                                                                                                                 |
| RUN        | Выполняет команду и создаёт слой образа. Используется для установки в контейнер пакетов.                                                                                                                   |
| COPY       | Копирует в контейнер файлы и директории.                                                                                                                                                                   |
| ADD        | Копирует файлы и директории в контейнер, может распаковывать локальные .tar-файлы.                                                                                                                         |
| CMD        | Описывает команду с аргументами, которую нужно выполнить когда контейнер будет запущен. Аргументы могут быть переопределены при запуске контейнера. В файле может присутствовать лишь одна инструкция CMD. |
| WORKDIR    | Задаёт рабочую директорию для следующей инструкции.                                                                                                                                                        |
| ARG        | Задаёт переменные для передачи Docker во время сборки образа.                                                                                                                                              |
| ENTRYPOINT | Предоставляет команду с аргументами для вызова во время выполнения контейнера. Аргументы не переопределяются.                                                                                              |
| EXPOSE     | Указывает на необходимость открыть порт.                                                                                                                                                                   |
| VOLUME     | Создаёт точку монтирования для работы с постоянным хранилищем.                                                                                                                                             |

### Каким образом в docker реализована изоляция контейнеров друг от друга? Какие средства linux для этого используются?(namespace)

Докер используется namespaces. Для создания изолированного рабочего пространства, которое называется контейнером.
При запуске контейнера докер создает набор неймспейсов для этого контейнера.

Эти неймспейсы обеспечивают уровень изоляции. Каждый аспект контейнера выполняется в отдельном контейнере и его доступ ограничен неймспейсом.

В частности в Docker Engine использует следующее:
- Пространство имен pid: Изоляция процессов (PID: идентификатор процесса).
- Пространство имен net: Управление сетевыми интерфейсами (NET: Networking).
- Пространство имен ipc: Управление доступом к ресурсам IPC (IPC: InterProcess Communication).
- Пространство имен mnt: Управление точками монтирования файловой системы (MNT: Mount).
- Пространство имен uts: Изолирование идентификаторов ядра и версий. (UTS: Unix Timesharing System).

### Почему в контейнере можно увидеть только процессы, запущенные в самом контейнере?

Это связано с тем, что Docker использует пространство имен PID (Process ID) для обеспечения изоляции процессов в контейнерах.
Когда создается новый контейнер, Docker создает новое пространство имен PID для этого контейнера и запускает процесс в этом пространстве имен.

В этом изолированном пространстве имен PID относится только к процессам, запущенным в том же контейнере.  
Это означает, что процесс в контейнере **может видеть только другие процессы в том же контейнере и не имеет возможности видеть процессы, запущенные в других контейнерах или на хост-системе**.
Это ключевой аспект изоляции и безопасности, обеспечиваемой контейнерами Docker.

### В папке /var/lib/docker/ как понять какая папка к какому контейнеру принадлежит

Например можно попробовать так:
```
docker inspect $(docker ps -qa) |  jq -r 'map([.Name, .GraphDriver.Data.MergedDir]) | .[] | "\(.[0])\t\(.[1])"'
```

### Какие типы сетей есть в докере

**bridge** - Это стандартная сеть по умолчанию, которая создает виртуальный мост (bridge) для обмена данными между контейнерами. Каждый контейнер получает собственный IP-адрес из диапазона сети Docker.

**host** - использует сетевой стек хоста, что означает, что контейнеры не изолированы на уровне сети от хоста. То есть, контейнер не изолирован по портам и делает запросы напрямую через сеть хоста.

**none** - контейнер не имеет доступа к сети.

**overlays** - тип сетей которые пересекают несколько узлов. Полезно когда у тебя docker контейнеры запушенны на разных хостах, но они должны общаться между собой. Для реализации этой сети Docker использует технологии, такие как **VXLAN** (Virtual Extensible LAN).

### Можно ли настроить сетевое взаимодействие между двумя docker-контейнерами? Как это реализовано?

Можно.
- Контейнеры должны быть частью одной сети
- Докер создает виртуальную сеть, default bridge и подключает к ней контейнеры. Также, использует драйвер overlay для многохостовых сетей
- В сети контейнерам назначается айпишник
- Если контейнеры имеют выход в большую сеть, то они ведут себя как программы на отдельных компах

Пример с сетевым драйвером bridge:

1. Создаем сеть
```
docker network create my_network
```

2. Запускаем два контейнера в сети (sleep 1d это для бездействия контейнера в течение дня. Полезно при дебаге порой):
```
docker run -d --name container1 --network my_network alpine sleep 1d
docker run -d --name container2 --network my_network alpine sleep 1d
```

3. Пробуем попинговать по имени:
```
docker exec -it container1 ping container2
ubuntu@host:~$ docker exec -it container1 ping container2
PING container2 (172.18.0.3): 56 data bytes
64 bytes from 172.18.0.3: seq=0 ttl=64 time=0.110 ms
64 bytes from 172.18.0.3: seq=1 ttl=64 time=0.083 ms
64 bytes from 172.18.0.3: seq=2 ttl=64 time=0.111 ms
```

 Это работает потому, что когда вы создаете контейнер в сети Docker, он получает собственный IP-адрес в этой сети и добавляет DNS-запись на DNS-сервер сети.
 Это позволяет контейнерам в одной сети взаимодействовать друг с другом, используя свои имена.
 Если вы хотите создать сеть на нескольких хостах Docker, используйте сетевой драйвер `overlay`.  
 Для этого потребуется Docker Swarm или стороннее хранилище ключевых значений, например Consul или etcd.

### Чем отличается _CMD_ от _ENTRYPOINT_ в Dockerfile?

Эти инструкции Dockerfile задают команду, исполняемую при запуске контейнера. При их использовании есть несколько правил, например:

- Должна быть минимум одна из них, CMD или ENTRYPOINT, в Dockerfile.
- Если контейнер используется как исполняемый файл — ENTRYPOINT должна быть определена.
- Если контейнер запускается с другими аргументами — CMD будет переопределена. Инструкция RUN позволяет вам установить ваше приложение и необходимые для него пакеты. Он выполняет любые команды поверх текущего изображения и создает новый слой, фиксируя результаты. Часто в Dockerfile вы найдете несколько инструкций RUN.

Хорошей иллюстрацией инструкции RUN может быть установка нескольких пакетов систем контроля версий:
```
RUN apt-get update && apt-get install -y \
bzr \
cvs \
git \
mercurial \
subversion
```

Обратите внимание, что `apt-get update`и `apt-get install`выполняются в одной инструкции RUN. Это делается для того, чтобы убедиться, что будут установлены самые последние пакеты. Если бы `apt-get install`это была отдельная инструкция RUN, то она бы повторно использовала слой, добавленный `apt-get update`, который мог быть создан давным-давно.
Инструкция CMD позволяет вам установить команду по _умолчанию_ , которая будет выполняться только тогда, когда вы запускаете контейнер без указания команды. Если контейнер Docker запускается с командой, команда по умолчанию будет игнорироваться. Если Dockerfile содержит более одной инструкции CMD, все инструкции CMD, кроме последней, игнорируются.

CMD имеет три формы:
- `CMD ["executable","param1","param2"]`
(исполнительная форма, предпочтительнее)
- `CMD ["param1","param2"]`_exec_
(устанавливает дополнительные параметры по умолчанию для ENTRYPOINT в форме
- `CMD command param1 param2`
(форма оболочки)
`docker run -it <image> /bin/bash` - тут при наличии CMD он будет проигнорирован, и будет запущен баш
Инструкция ENTRYPOINT позволяет настроить контейнер, который будет работать как исполняемый файл. Он похож на CMD, потому что также позволяет указать команду с параметрами. Разница заключается в том, что команда ENTRYPOINT и параметры не игнорируются, когда контейнер Docker запускается с параметрами командной строки. (Есть способ игнорировать ENTTRYPOINT, но вряд ли вы это сделаете.)

Докерфайл
```
ENTRYPOINT ["/bin/echo", "Hello"]
CMD ["world"]
```

когда контейнер запускается, как `docker run -it <image>`будет производиться вывод
```
Hello world
```

но когда контейнер запускается, `docker run -it <image> John`это приведет к
```
Hello John
```

- Краткий ответ
cmd подставится после entrypoint при запуске. Тем самым можно запускать контейнер с нужными параметрами.
То есть в entrypoint можно передать бинарь, а в cmd передать параметры.
CMD может перетереться просто.

### Что происходит когда пишешь ENTRYPOINT?

Точка входа в приложение.

Это инструкция в докерфайле, которая всегда будет выполняться при запуске контейнера.
Она часто используется для определения основной команды для запуска контейнера.
Например для запуска веб-сервера или какой-либо иной службы.

Что происходит пошагово:  
Инструкция ENTRYPOINT в Dockerfile задает команду, которая всегда будет выполняться при запуске контейнера. Она часто используется для задания основной команды для запуска контейнера, например, для запуска веб-сервера, базы данных или службы.
Вот что происходит шаг за шагом:

1. В процессе сборки образа Docker читает Dockerfile строка за строкой, сверху вниз. Когда Docker встречает инструкцию ENTRYPOINT, он записывает команду и ее аргументы.

2. После сборки образа, при запуске контейнера из этого образа Docker выполняет команду, указанную в инструкции ENTRYPOINT.

3. Если команда Docker run также включает в себя команду, то она передается в качестве аргумента команде ENTRYPOINT.

Например, если у вас есть Dockerfile со следующим ENTRYPOINT:
```
ENTRYPOINT ["/app/start.sh"]
```

И запускается контейнер из этого образа с помощью команды:
```
docker run -it my_image echo "Hello, World!"
```

Докер выполнит команду ENTRYPOINT с командой run в качестве аргумента:
```
/app/start.sh echo "Hello, World!"
```

Обратите внимание, что команду ENTRYPOINT можно отменить при запуске контейнера, используя флаг `--entrypoint` в команде `docker run`.
В этом основной смысл, что можно переопределить аргумент, или вообще его отменить.

### В чем разница между ADD и COPY

В Dockerfile, инструкции `ADD` и `COPY` обе используются для копирования файлов и директорий из локальной файловой системы в образ контейнера, но между ними есть несколько важных различий:

  - **COPY** поддерживает **только** базовое копирование локальных файлов в контейнер
  - **ADD** имеет дополнительный функционал, к примеру, может извлекать архивы (напр, .tar, .tar.gz, .zip и другие форматы) и загружать файлы по URL. Но если, например, копировать через него архив, то он распакуется как каталог. Это уменьшает размер образа

В большинстве случаев предпочтительнее использовать COPY, так как это более предсказуемо и ясно, а ADD стоит использовать только тогда, когда вам действительно нужны её дополнительные возможности, такие как извлечение архивов или загрузка файлов по URL.

### В чем отличие ARG от ENV?

**ENV** позволяет создавать переменные окружения, которые будут работать во время работы контейнера.
**ARG** позволяет закинуть переменные, которые будут доступны во время сборки. Но они недоступны в контейнере. Однако через `ARG` можно задавать значения переменных по умолчанию для `ENV`

### Какие есть best practices для написания Dockerfile?

1. Запускать только один процесс на контейнер.
2. Стараться объединять несколько команд RUN в одну для уменьшения количества слоёв образа.
3. Частоизменяемые слои образа необходимо располагать ниже по уровню, чтобы ускорить процесс сборки, т.к. при изменении верхнего слоя, все нижеследующие слои будут пересобираться.
4. Указывать явные версии образов в инструкции FROM, чтобы избежать случая, когда выйдет новая версия образа с тегом latest.
5. При установке пакетов указывать версии пакетов.
6. Очищать кеш пакетного менеджера и удалять ненужные файлы после выполненной инструкции.
7. Использовать multistage build для сборки артифакта в одном контейнере и размещении его в другом.

### Какие типы сетевых драйверов используются в docker?

Основные драйвера сетей docker: bridge, host, overlay, ipvlan, macvlan, none

**bridge:** это сетевой драйвер по умолчанию. Бридж сеть используется, когда ваши приложения запускаются в автономных контейнерах, которые должны взаимодействовать между собой.

Взаимодействие с хостом выполняется через мост docker0 и конфигурацию таблицы iptables nat. В этом режиме будет выделено сетевое пространство имен, задан IP-адрес для каждого контейнера, а контейнер Docker на хосте будет подключен к виртуальному мосту. Виртуальный мост работает как физический коммутатор, поэтому все контейнеры на хосте подключены к сети уровня 2 через коммутатор.

**host:** использует сеть хоста напрямую без изоляции контейнера и хоста.

**none:** этот режим помещает контейнер в свой собственный сетевой стек, но не выполняет никакой настройки. Фактически, этот режим отключает сетевую функцию контейнера, что полезно в следующих двух ситуациях: контейнер не требует сети (например, только для пакетной задачи записи дисковых томов).

**macvlan:** в режиме Macvlan Bridge каждый контейнер имеет уникальный MAC-адрес, который используется для отслеживания сопоставления MAC-адреса с портом хоста Docker. Сеть драйвера Macvlan подключается к родительскому интерфейсу хоста Docker. Примерами являются физические интерфейсы, такие как eth0, субинтерфейс eth0.10 для тегирования VLAN 802.1q (.10 означает VLAN 10) или даже связанный хост-адаптер, который объединяет два интерфейса Ethernet в единый логический интерфейс. Назначенный шлюз является внешним по отношению к хосту, предоставляемому сетевой инфраструктурой. Каждая сеть Docker в режиме Macvlan Bridge изолирована друг от друга, и только одна сеть может быть подключена к родительскому узлу одновременно. Каждый хост-адаптер имеет теоретический предел, и каждый хост-адаптер может подключаться к сети Docker. Любой контейнер в той же подсети может взаимодействовать с любым другим контейнером в той же сети без шлюзового моста macvlan. Та же сетевая команда docker применяется к драйверу vlan. В режиме Macvlan без внешней маршрутизации процессов между двумя сетями / подсетями контейнеры в разных сетях не могут получить доступ друг к другу. Это также относится к нескольким подсетям в одной и той же терминальной сети.

**overlay:** Оверлейные сети соединяют несколько демонов Docker вместе и позволяют сервисам swarm взаимодействовать друг с другом. Вы также можете использовать оверлейные сети для облегчения связи между сервисом swarm и автономным контейнером или между двумя автономными контейнерами в разных демонах Docker. Эта стратегия устраняет необходимость выполнять маршрутизацию между этими контейнерами на уровне ОС.

**ipvlan:** Сети ipvlan предоставляют пользователям полный контроль над адресацией IPv4 и IPv6. Драйвер VLAN построен на основе этой возможности, предоставляя операторам полный контроль над тегированием VLAN уровня 2 и даже маршрутизацией IPvlan L3 для пользователей.

### Что такое эфемерные контейнеры?

[Эфемерные контейнеры](https://kubernetes.io/docs/concepts/workloads/pods/ephemeral-containers/) стали бета-функцией в Kubernetes v1.23 и теперь включены по умолчанию.
Эфемерные контейнеры предназначены для транзитных задач, когда вам нужно временно [подключить дополнительный контейнер к существующему поду](https://kubernetes.io/docs/tasks/debug/debug-application/debug-running-pod/#ephemeral-container). Это идеально подходит для отладочных операций, когда вы хотите проверить поды, не затрагивая живые экземпляры контейнеров.

### Какие команды порождают слои?

`RUN` порождает слои

### Что за none образы можно увидеть в docker images?

Каждый образ в докере состоит из слоев, и имеет дочерние связи с другими слоями. По умолчанию они лежат в `/var/lib/docker/graph`.
И когда мы закачиваем новую версию образа, то образ подгружает слой раз за разом. И получается что none это лишь один из слоев.
Этот образ называется промежуточным. Их можно увидеть с помощью `docker images -a`
Также, есть обособленные образы none:none. Например, когда мы собираем примерно такой же образ, но например с иной версией операционной системы.
И в этом случае будет создан именно такой образ. Поскольку мы пересобрали образ с помощью докерфайла, а старая система стала обособленной.

Можно почистить так:
```
docker rmi $(docker images -f "dangling=true" -q)
```

### Что такое squash сквош?

Это штука, позволяющая все слои спушить в один. В качестве побочного эффекта - размер образа уменьшается.
Но он ломает кэширование, поскольку у нас всё в одном слое.
С одной стороны инструмент мощный. Но нужно обращаться осторожно.
Лучше для базового образа использовать. Заранее набросал, и вот у тебя образ.

### Что такое Docker squash?

Это утилита на питоне, которая позволяет объединить слои в один.
Также это экспериментальный параметр с помощью которого можно создать сжатый образ.

### Можно ли ограничить использование ресурсов (cpu, ram, io, network) для docker контейнера? Как это реализовано? (cgroup)\*\*

Можно. И делается через cgroup. В модуле ядра.
А можно посмотреть в докере как ключи ставить
[https://docs.docker.com/config/containers/resource_constraints/](https://docs.docker.com/config/containers/resource_constraints/)

### Для решения каких задач применяется docker-compose?

Docker Compose — это инструментальное средство, входящее в состав Docker. Оно предназначено для решения задач, связанных с развёртыванием проектов.
Вы передаёте файл с инструкциями для docker-compose, настроечными файлами, и докер на месте собирает из этого нужную вам комбинацию контейнеров, подтягивает образы нужных версий, пробрасывает в них волюмы с данными, поднимает между ними локальные сети и настраивает порты обмена.

### Что такое контейнеризация? Чем она отличается от виртуализации?

![ContVSVirt](./img/docker/cont_vs_virt.png)
Если говорить о виртуальных машинах, там они работают через **Виртуализацию**
И машины создаются с помощью гипервизора. И все аппаратные составляющие создаются через нее. И затем на нее накатываются операционные системы.
Соответственно, ресурсы машины будут уходить на поддержание работы запущенной операционной системы.
При контейнеризации аппаратные ресурсы выделяются с помощью ядра операционной системы, и изолируются пространством имен. Следовательно, они потребляют меньше ресурсов, и быстрее пересоздаются.
Плюсы:
- Меньше ресурсов потребляется
- Быстрый запуск
### Что такое виртуализация? Чем виртуализация отличается от эмуляции?

Виртуализация очень похожа на эмуляцию, но между ними есть важные различия. В частности, виртуализация обычно относится к использованию виртуальных машин. Виртуализация и эмуляция выполняют одно и то же, но делают это немного по-разному.
Оба предназначены для запуска программного обеспечения в изолированной среде. Виртуализация ориентирована на изоляцию, а эмуляция — на среду. Это означает, что эмуляторы имитируют большее количество оборудования, чем виртуальные машины.
Например, вы не можете запустить систему PlayStation на виртуальной машине. Но вы можете запустить эмулятор PlayStation в виртуальной среде Windows.
Эмуляция-это использование программного обеспечения для обеспечения другой среды выполнения или архитектуры. Например, у вас может быть эмулятор Android, запущенный на коробке Windows. Коробка Windows не имеет того же процессора, что и устройство Android, поэтому эмулятор фактически выполняет приложение Android с помощью программного обеспечения.
Виртуализация-это скорее создание виртуальных барьеров между несколькими виртуальными средами, работающими в одной и той же физической среде. Большая разница заключается в том, что виртуализированная среда представляет собой одну и ту же архитектуру. Виртуализированное приложение может предоставлять виртуализированные устройства, которые затем преобразуются в физические устройства, и узел виртуализации контролирует, какая виртуальная машина имеет доступ к каждому устройству или части устройства. Однако фактическое выполнение чаще всего все еще выполняется изначально, а не с помощью программного.

### В чем разница между `docker stop` и `docker pause`?

В том, что они посылают разные сигналы
`docker pause` - SIGSTOP(19), что приостанавливает процессы в контейнере
`docker stop` - SIGTERM(15) и SIGKILL(9) использует к главному процессу контейнера

### Что такое слои в докере?

По сути, слой или _слой образа_ это изменение образа или **промежуточного образа**. Каждая команда, указанная (`FROM`, `RUN`, `COPY` и т.д.) в вашем Dockerfile вызывает предыдущий образ изменения, создавая тем самым новый слой. Вы можете думать об этом как о внесении изменений при использовании git: вы добавляете изменение файла, затем еще одно, затем добавляя ещё одно, и слои накладываются один за другим.

Так же любые изменения, которые происходят в docker контейнере, автоматически записываются в новый слой.


### Почему latest образы использовать нежелательно?

Сложно в отладке как минимум. Не разобраться какая именно версия закосячила. А так прод работает на определенной версии, пусть дальше на ней и работает.
Помимо этого это небезопасно. Никто не знает что выкатит разработчик в новой версии. Может не быть обратной совместимости в проекте.

### От кого по умолчанию запускается контейнер? Почему это плохо?

Процесс внутри пользователя запускается от root. id = 0.
Лучше вот так делать
```docker
FROM alpine
RUN groupadd -r myuser && useradd -r -g myuser
<Здесь еще можно выполнять команды от root-пользователя, например, ставить пакеты>
USER myuser
```
Можно таким образом нарушить изоляцию и получить рутовый доступ.
Ну и не все запускают от рута в итоге

### Как убить контейнер изнутри?

Через sigkill нельзя. Нужен обработчик сигнала. Sigkill я зарегистрировать не смогу. И игнорировать этот сигнал тоже. Но можно обрабатывать sigterm. И его использовать для выхода из приложения. [https://medium.com/@andrestc/killing-a-container-from-the-inside-b4923f3a4182](https://medium.com/@andrestc/killing-a-container-from-the-inside-b4923f3a4182)

### Возможен ли самостоятельный перезапуск контейнера?

Да, можно вот так указать: `docker run --restart=always`

### Что такое ката kata контейнер?

Это иная реализация контейнеров. Которые работают в оси под открытой инициативой. **Kata Containers** объединяют преимущества контейнеров и виртуальных машин (VM). Они обеспечивают более высокий уровень **изоляции и безопасности** для приложений, сохраняя при этом **лёгкость и скорость работы контейнеров**.  
Если обычные контейнеры используют стандартные механизмы контейнеризации Linux, у **Kata Containers** используются qemu, kvm.
Контейнер на стероидах. Больше для безопасности придумано.

### CRI, CSI, CNI, что это ?

**CRI** ( container runtime interface ) - это интерфейс который отвечает за жизенный цикл контейнера и среду выполнения этого контейнера ( docker, containered и тд. )

**CSI** ( container storage interface ) - это интерфейс который позволяет, как я понял, стандартизировать подключения каких то хранилищ к контейнеру

**CNI** ( container network interface ) - это интерфейс, который позволяет тюнить сетевые взаимодействия как между контейнерами ( создает сетевые окружения для пода + занимается маршрутизаций трафика между подами и нодами )

| Термин | Описание                                                                                                                                              | Область применения                         | Уровень взаимодействия                                  | Примеры реализации        |
|--------|-------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------|---------------------------------------------------------|---------------------------|
| **CRI** | Интерфейс для управления жизненным циклом контейнеров в Kubernetes. Позволяет Kubernetes взаимодействовать с различными средами выполнения контейнеров. | Оркестрация и управление контейнерами       | Инфраструктурный уровень, взаимодействие с контейнерами  | Docker, containerd, CRI-O |
| **CSI** | Стандарт для подключения систем хранения данных к контейнерам. Позволяет интегрировать разные решения для управления данными в контейнерах.             | Хранение и доступ к данным в контейнерах    | Инфраструктурный уровень, взаимодействие с системами хранения | OpenEBS, Rook, Portworx   |
| **CNI** | Спецификация для настройки сетевых интерфейсов контейнеров. Управляет сетевыми настройками и политиками безопасности для контейнеров.                   | Управление сетями и коммуникацией контейнеров | Интерфейс для сетевых плагинов на уровне контейнеров     | Calico, Flannel, Weave Net |

### Разработчики собрали образ, и запустили докер контейнер. При запуске выдает ошибку /bin/bash not found. Как диагностировать проблему?

Попробовать запустить с sh, bash переопределив энтрипоинт
```
docker run  --entrypoint="/bin/sh"
```

### Как уменьшить размер образа докера? У нас много COPY, RUN

1. Использовать специальные облегченные базовые версии докер-образов.
2. Уменьшать размер слоев, запуская RUN нечасто, объединив команды в одну
3. Не устанавливать рекомендованные пакеты. И удалять содержимое `/var/lib/apt/lists/*`
4. Docker-multistage-build. Тут указываем несколько `FROM`. И можно копировать результат одного `FROM-а` в другой

Пример
```
# 1 =====================================
# специальный образ, который содержит все необходимые
# для сборки библиотеки и приложения
# размер образа ~730mb
FROM diproart/ruby:2.6.4-alpine3.10 AS builder

# полный набор пакетов
ENV COMMON_PACKAGES \
tzdata \
   ...

ENV ..

RUN set -xe \
   && apk update \
   && apk upgrade \
   && apk add --no-cache --update ${COMMON_PACKAGES} \
   && rm -rf /var/cache/apk/* /tmp/* /var/tmp/*

# additional clean
#RUN rm -rf /usr/local/bundle/cache/*gem

RUN mkdir -p /usr/src/app
WORKDIR /usr/src/app
COPY . .
RUN

# 2 =====================================
# чистый образ, в который добавим только самое необходимое
# размер образа ~51mb
FROM ruby:2.6.4-alpine3.10

# только необходимые для работы
# в production пакеты
ENV PRODUCTION_PACKAGES \
tzdata \
   ...

ENV ...

RUN set -xe \
   && apk update \
   && apk upgrade \
   && apk add --no-cache --update ${PRODUCTION_PACKAGES} \
   && rm -rf /var/cache/apk/* /tmp/* /var/tmp/*

RUN mkdir -p /usr/src/app
WORKDIR /usr/src/app

WORKDIR /usr/src/app

# копируем скомпилированное приложение
# и пакеты в напрямую в образ из предыдущего шага
COPY --from=builder /usr/src/app .
COPY --from=builder /usr/local/bundle/ /usr/local/bundle/

EXPOSE 3000
ENTRYPOINT [ "bundle", "exec" ]
CMD [ "rails", "s", "-b", "0.0.0.0" ]
```

