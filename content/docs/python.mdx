---
title: Python
icon: SiPython
---
## Вопросы
### Хеш-таблица

#### Что такое хеш-таблица?
**Хеш-таблицы** — это структура данных, где адрес или индекс элемента генерируется с помощью **хеш-функции**. Это позволяет ускорить доступ к данным, так как значение индекса используется как ключ для поиска соответствующего значения. В хеш-таблице хранятся пары **ключ-значение**, где ключ создаётся при помощи функции хеширования.
Хеш-таблицы широко используются в программировании для быстрого поиска, добавления и удаления данных.
#### Пример использования хеш-таблиц
Одним из примеров использования хеш-таблиц являются **чит-коды** в играх, таких как **GTA San Andreas**. Те слова, которые игроки вводят в виде чит-кодов, на самом деле не являются изначально задуманными командами разработчиков. Эти слова проходят через хеш-функцию, которая преобразует их в ключи, связанные с конкретными командами в игре.
Таким образом, хеш-таблицы позволяют обрабатывать чит-коды, сопоставляя введённые символы с заранее заданными значениями в игре, что значительно упрощает работу с большим количеством данных.

### Что такое генератор, что такое итератор?

#### Итератор
**Итератор** — это сущность, которая упрощает навигацию по коллекции данных. С помощью итератора можно перебрать значения в списке, применяя к каждому элементу определённую функцию. Итераторы позволяют последовательно получать элементы из коллекций, таких как списки, кортежи или множества.
#### Генератор
**Генератор** — это объект, который генерирует значения по мере их запроса. Генераторы похожи на списки, но отличаются следующими особенностями:

- Генератор не вычисляет все значения сразу при создании. Значения генерируются по мере необходимости.
- В памяти хранится только последнее вычисленное значение, а также правило перехода к следующему элементу и условие остановки генерации.
- Вычисление следующего значения происходит при вызове метода `next()`. Предыдущее значение при этом теряется.

### В чем разница между кортежем и списком?

1. **Изменяемость (Mutable vs Immutable)**:
	- **Список** можно изменять после создания. Элементы можно добавлять, удалять или изменять.
	- **Кортеж** является неизменяемым объектом. После создания кортежа его содержимое нельзя изменить.

2. **Производительность**:
	- **Кортеж** работает быстрее, чем список, при итерации и доступе к элементам, так как из-за своей неизменяемости он оптимизирован лучше. Это делает его предпочтительным выбором для данных, которые не изменяются.
	- **Список** медленнее, так как его структура предусматривает возможность модификации данных.

3. **Использование памяти**:
	- **Кортежи** занимают меньше памяти по сравнению со списками за счёт своей неизменяемости.
	- **Списки** требуют больше памяти, так как резервируют пространство для возможных изменений.

4. **Функциональность**:
	- **Списки** поддерживают множество методов, таких как `append()`, `remove()`, `extend()`, и другие, позволяющие изменять его содержимое.
	- **Кортежи** не поддерживают методы изменения, так как они неизменяемы, но могут быть использованы методы, такие как `count()` и `index()`.

5. **Использование**:
	- **Список** используется, когда данные могут изменяться, например, список задач, товаров или пользователей.
	- **Кортеж** обычно используется для хранения данных, которые не должны изменяться, например, координаты точки (x, y), дата или параметры конфигурации.

6. **Хешируемость**:
	- **Кортеж** хешируем (если все его элементы также хешируемы), что позволяет использовать его в качестве ключа в словарях или элемента в множестве.
	- **Список** не является хешируемым и не может быть ключом в словарях или элементом в множестве.

7. **Безопасность**:
	- **Кортеж** благодаря своей неизменяемости является более безопасным для данных, которые не должны изменяться. Это предотвращает случайные или преднамеренные изменения данных.
	- **Список**, наоборот, можно случайно изменить, что может привести к нежелательным последствиям.

8. **Синтаксические различия**:
	- **Список** создаётся с помощью квадратных скобок: `my_list = [1, 2, 3]`
	- **Кортеж** создаётся с помощью круглых скобок: `my_tuple = (1, 2, 3)`  
_Примечание_: если кортеж содержит один элемент, необходимо указать запятую: `single_element_tuple = (1,)`

Вывод:
- Если вам нужна структура данных, которую можно изменять, используйте **список**.
- Если ваши данные неизменяемы, и вам важна оптимизация памяти и производительности, выбирайте **кортеж**.

### Что такое декоратор?

Декоратор позволяет добавить новую функциональность к существующей функции. Это делается следующим образом. Функция передается декоратору, а он выполняет и существующий, и дополнительный код.
**Напишите функцию декоратора**. В качестве аргумента он принимает функцию `func`. Декоратор определяет функцию log_function_called, которая вызывает `func()` и выполняет некоторый код `print(f'{func} called.’)`. Затем возвращает определенную им функцию:

```python
def logging(func):
    def log_function_called():
        print(f'{func} called.')
        func()
    return log_function_called
```

Напишем другие функции, к которым добавим декоратор (потом, не сейчас):
```python
def my_name():
    print('chris')

def friends_name():
    print('naruto')

my_name()
friends_name()
# => chris
# => naruto

```

Теперь добавим декоратор к ним обоим.
```python
def logging(func):
    def log_function_called():
        print(f'{func} called.')
        func()
    return log_function_called


def my_name():
    print('chris')


@logging
def friends_name():
    print('naruto')


my_name()
friends_name()

# => chris
# => <function friends_name at 0x10fca5f28> called.
# => naruto
```

Теперь легко добавить ведение журнала в любую функцию, которую мы пишем. Достаточно написать перед ней @logging.

### Какое значение принимает переменная в Python, которая не имеет значения?

Будет иметь значение `None`
